-*- org -*-


* TODO Misc
** TODO <2015-01-05 mån> abs_syn_gen.TestCase instances must be valid
The constructor should validate all arguments
The list of phases must:
- be ordered according to phase execution order
- type of environment must be correct for each phase

** DONE <2015-01-05 mån> May be StatementsGeneratorForInstruction should not be given ScriptLanguage
... since each StatementsGeneratorForInstruction is probably not designed to
handle an arbitrary language.
Giving a ScriptLanguage to apply, indicates that it should be capable of
handling arbitrary languages.

* TODO Kommandorads-program
** TODO Hjälpsystem via CLI
Förslag:
*** -h | --help : Elementär hjälp. Hjälp för hur använda kommandot "help"
*** Kommando "help" : om skrivs som första argument på CL
**** Enbart "help" : hjälp om hur använda "help"
**** help phase : Översikt över faserna
I vilken ordning de körs och deras inbördes roller.
**** help phase PHASE : Detaljerad info om fasen PHASE
**** help instruction : Översiktlig hjälp om instruktioner
**** help instruction INSTRUCTION : Detaljerad info om instr INSTRUCTION
** TODO Funktion för att köra assert/execute på given EDS
För felsökning av assert.
Tänkt användning:
1. Kör hela snurran (ev utom cleanup), och spara EDS.
   Troligtvis ger assert ett oväntat resultat som behöver felsökas.
2. Mixtra med innehållet i EDS.
3. Kör assert/execute på given EDS.
4. Upprepa 2-3 tills assert ger förväntat resultat.
5. Rätta till felet (i SUT, setup, act, el assert).
6. Radera EDS manuellt, eller kör shellcheck m växel som enbart kör cleanup,
   inklusive automatisk radering av EDS.  Kör denna mot angiven EDS.
* TODO Formgivning av instruktionsuppsättning
** Anonyma fasen: Fixerad mängd instruktioner
Icke konfigurerbar pss som övriga faser, iom att denna fas har en speciell
uppgift att styra kommande faser.
** Instr har antingen arg enl argparse, eller skräddarsydd parsning
Skräddarsydd parsning funkar bäst för t ex instr i act-fasen som enbart är
källkod som ska kopieras till skriptet.
** Generella instr: Instr som kan köras i alla namngivna faser
Borde gå/finnas behov av att skriva generella instruktioner som kan köras i
vilken som helst av de namngivna faserna, eller kanske snarare, i vilken som
helst av faserna som har tillgång till EDS.
*** Ta fram SGD för dessa instruktioner (t ex EDS + HOME)
Ev är problemet här fasen "setup", vars "validate" inte har tillgång till EDS.
Kanske är det av den orsaken värt att skapa EDS innan setup/validate.
* TODO Test result
** TODO <2015-05-03 sön> Enhetstester för fast-steg-exekverare
Blir redundans om alla dess varianter ska testas via integrationstest.
Fallet som för tillfället orsakar problem är huruvida en fallerande
instruktion är den sista i raden eller ej.  (O borde kanske även testa då den
är den första ... dvs behöver UTFÖRLIGA tester av det här!)
** TODO <2015-05-03 sön> Använd mest informationsbärande status-koder internt
Fler fördelar:
 - möjliggör mest utförliga testerna
 - detfinns fler "externa" standarder: om har interna kan man översätta till
   godtycklig extern standard och kan på så vis integrera programmet i flera
   olika ramverk.
** TODO <2015-01-05 mån> Handle implementation errors
** TODO <2015-01-05 mån> Handle parse errors
** TODO <2015-01-05 mån> Handle errors correctly according to phase
* TODO Specifika instruktioner
** alla faser: Byta katalog till testrooten
Tycker för tillfället det är vettigast att varje fas inte inleds med att
automatiskt byta katalog till testroten.  Främsta anledningen är att
act-fasens byte av katalog måste betraktas som en sidoeffekt av programmet
som testsas och därmed som något man vill testa.

Även vettigt att setup-fasen kan skapa tmp-katalog och byta till den för att
köra act-fasen innifrån den (användbart t ex om act-fasen raderar aktuell
katalog).  Därmed är det vettigt att inte heller act-fasen inleds med att
automatiskt byta katalog.

Dock.  Vore bra om det enkelt gick att byta till testroten för att ha en fast
ugångspunkt för assert, cleanup, ...
Därför vore det bra med en instruktion som byter till denna katalog.

Problem ... hur ser man till att aktuell katalog bevaras från act-fasen om
den kör i en egen process??
** Sätt systemets TMP-katalog till ${SHELLCHECK_TMP}
Används antingen i setup eller anonyma fasen.
** Skapa temporär fil (filnamn tas fram automatiskt, läggs i SHELLCHECK_TMP)
** file
*** Separata instr för test av filtyp samt innehåll
T ex
content target.txt empty
content target.txt --rel-home source.txt

type target.txt dir
type target.txt file
*** Använda syntax mer lik unix "test" och "find"?
Fördel iom att den är välkänd.
** file/stdout/stderr --rel-cwd
*** HARD_ERROR ifall jämförelsefilen inte finns?
Nu ges FAIL: felet betraktas som en form av olikhet.
* TODO Förbättringar
** TODO <2015-05-17 sön> Bevara glob tillstånd
Idag sparas omgivningsvariabler "runt" partiell exekvering.  Borde sparas runt
"full" exekvering, naturligtvis.
Vore bäst (känns nu) om hela exekveringen kunde ske i sub-process.
** TODO <2015-05-18 mån> Ev skapa EDS senare
Enl diagram ska den skapas precis efter setup/validate.
Idag skapas den precis innan setup/validate.
Ingen stor grej, men kan ev ändras.
Alternativ ändrar man spec till att göra som idag.
** TODO <2015-05-22 fre> Konfbar gemensam miljö för alla instruktioner
Införa argument som ges till alla metoder i alla instruktioner.
Skulle erbjuda mölighet att skräddarsy den information som instruktionerna har
tillgång till.
* TODO Refaktoreringar
** TODO Argument till instruktionernas steg
Spikade först två generella miljöer: global miljö och fas-miljö.
Iom att den modellen inte längre används kan mer ändamålsenliga argument
användas.
*** TODO act/script-gen
Två argument:
1. Skriptbyggare
2. Inställningssättare (för t ex stdin).
** TODO Använda nya TestCaseSetup i äldre tester
Som du finns flera instruktions-klasser som enbart returnerar ett visst värde
eller kastar undantag.  Alla de fallen kan hanteras av nya TestCaseSetup.
* TODO Parsning av multi-rader
Har spånat (o experimenterat m två varianter)
** b-sne:
rad\
fortsätter\
mha b-sne

Har experimenterat m pythons shell-parsning.  (finns ev exempel nånstans).
Har kommit fram till att det går hyfsat att detektera b-sne på slutet av
raden - som inte ingår i quotade strängkonstanter.
** here-dokument
<<<EOF
Anger en sekvens av rader
på samma
sätt som HERE-dokument i shell.
EOF
** BNF
Tänker mig dok-syntax ("nivå 0") ung
rad ::= tom
      | kommentar
      | fasrubrik
      | instruktion
instruktion ::= enkel-radare
              | here-block
              | bne-separerade rader
* TODO Preprocessor
Vore bäst om programmet innehöll en egen preprocessor.
På så vis maximeras oberoende av yttre miljön.
Funktionallitet:
- filinklusion
- definitioner av konstanter
- definitioner av funktioner
Har tittat på:
** PYM (mest lovande)
http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.400
* TODO Härleda interpretator
bash, sh, csh ...???
Går det att ta reda på ett utgångsvärde för interpretator för varje plattform
(dvs via python)?  El måste den anges explicit?
* TODO Testa på andra plattformar (Windows, Mac)
Ev måste hanteringen av ny-rader justeras.
python har ju något som heter "universal newlines".  Ev ska det användas (om
det inte redan används idag!)
* TODO Svit
** TODO Hjälp-funktionallitet för svit-kommandot
** TODO Svit: Reffa flera fall-filer mha jokertecken
Typ:
[cases]
sub-dir/*.case

** TODO Gruppering av testfall
Ev ange i varje enskilt testfall:
groups database groupX groupY

Ev ange i svit-filerna.  På sätt o vis är det ju enbart i svit-filerna grupper
är relevanta iom att det enbart där är meningsfullt att arbeta med grupper av
fall.
Skulle kunna ha instruktion "@groups" i svit-filer (mycket liknande hur
filelist använder @tags).
** TODO Köra enskilda testfall i sub-process
** TODO <2015-07-14 tis> Rapportering: Borde inte rappoteringen vara rekursiv?
Nu (djupet-först):
----------------------------------------
sub-suite: BEGIN
sub-case: PASS
sub-suite: END

main-suite: BEGIN
main-case: PASS
main-suite: END
----------------------------------------
Borde det inte vara:
----------------------------------------
main-suite: BEGIN

sub-suite: BEGIN
sub-case: PASS
sub-suite: END

main-case: PASS
main-suite: END
----------------------------------------

Dagens impl har fördelningen att en svits BEGIN o END inkapslar "direkt"
svitens egna testfall.
Nackdelen är att det inte går att spåra inklusions-hierarkin.
Frågan är vad som är vettigast.  Borde kolla på hur andra gör o följa det
vanliga sättet.
(Makefiler kör enl icke-nuvarande.  Å andra sidan har man inget val där, iom
att det handlar om att "överliggande" moduler är beroende av "underliggande".
El, jo, i rapporteringen har man naturligtvis ett val!  Dock inte i själva
beräkningsordningen.)
* TODO Loggning
