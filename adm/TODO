-*- org -*-

* TODO Paketstruktur: flytta act_phase_setup till test_case.act
Kanske.
El är test_case.act till för enbart instruktoner?
act_phase_setup kanske tillhör exekvering mer
* TODO main-program: möjl att köra flera tester m en o samma kommandorad
Typ: Om fler än en tesfalls-fil anges så körs de som en test-svit.

En temporär testsvit skapas bakom kulisserna.
* TODO Python-saker

** TODO Är klasser py3? Ska det vara MyClass(object)?
Ev ska varje klass explicit ärva object för att vara en py-3-klass.
* TODO shell: Vad händer m stdout, stderr? blir del av stdout för shellcheck?
Verkar så.  Väldigt dåligt i så fall.  Måste ändras.
** TODO stdout, stderr
Skriv dessa till fil pss som görs för execute.
* TODO timeout för instruktioner som kör subprocesser
subprocess.call(timeout=...)
* TODO tmp-filer för instruktioner
Bör införa hjälpfunktion för att skapa tmp-filer för instruktioner.
Nu: contents/stdout/stderr: Ser själva till att lägga tmp-fil i
tmp/internal.
Vill ha funktion, typ: tmp_file_for_instruction(prefix,suffix,contents)
-> pathlib.Path
som automatiskt lägger den i tmp/internal.
* TODO cwd för act-exekveringen
Ser ut som det är fel idag, dvs att act_dir används ovillkorligt.
Ska vara: cwd.
                exitcode = self.__script_handling.executor.execute(
                    self.__source_setup,
                    self.execution_directory_structure.act_dir,
                    self.configuration.home_dir,
                    self.__execution_directory_structure,
                    StdFiles(f_stdin,
                             StdOutputFiles(f_stdout,
                                            f_stderr)))

** Säkerställ: om stdin ska omdirigeras att filen hittas
Idag är cwd alltid (troligtvis) act-dir. Då kan sökvägar vara relativa denna.
Ev måste det hanteras om cwd kan vara nått annat.
* TODO Syntax för instruktioner: vänta till EXPECTED ACTUAL??
Bör se på om det är möjligt.
T ex
5 exitcode
empty stdout
empty file.txt
contents --rel-home expected stderr
type directory my-file

Känns faktiskt aningen konstigt.  Spec exitcode. O även empty.
* TODO Alias för instruktioner
Kan behövas för att attrahera utvecklare med olika bakgrund.
Speciellt
 - "pwd" kan behöva heta "cd"
 - "dir" kan behöva heta "mkdir"
Dock, ett alt är naturligtvis att skapa alias m makron.  Är nog det enklaste,
trots allt, iom att det förenklar programmets struktur, och funktionalliteten
oavsett kommer att finnas iom makroprocessor.
* TODO Dokumentation
** TODO Hjälpsystem
** TODO Users Guide
** TODO Reference Manual
* TODO Tester som inte är skrivna
** TODO content/stdout/stderr --with-replaced-env-vars körd > 1 gång
Eftersom befintliga transformerade filer återanvänds är beteendet annorlunda
för användning nr > 1, än första gången. Måste alltså testas.
Metod: Ev köra helt testfall o helt enkelt använda samma instruktion två
gånger.
** TODO default main program: kolla att faserna innehåller rätt instruktioner
----------
Scenario:
Alla tester passerades
men gick inte att köra programmet pga att instruktionsuppsättningen var fel.
Instruktionerna för fasX låg i fasY, typ.
Felet var felaktig sekvens av argumenten till InstructionsSetup i
shellcheck_lib/default/execution_mode/test_case/default_instructions_setup.py
----------

Lösning, typ: test som kör testfall m en "unik" instruktion från varje fas.
("unik" = instruktion som inte finns i någon annan fas.)
* TODO Misc
** TODO <2015-01-05 mån> abs_syn_gen.TestCase instances must be valid
The constructor should validate all arguments
The list of phases must:
- be ordered according to phase execution order
- type of environment must be correct for each phase

** DONE <2015-01-05 mån> May be StatementsGeneratorForInstruction should not be given ScriptLanguage
... since each StatementsGeneratorForInstruction is probably not designed to
handle an arbitrary language.
Giving a ScriptLanguage to apply, indicates that it should be capable of
handling arbitrary languages.

** TODO <2015-09-25 fre> EDS: test-root ska heta "act"
Mkt enklare att koppla ihop med fasen "act".

** TODO Ska omgivningsvariablerna ha ett "_DIR" på slutet?
Känns vettigt.  Tydligare, helt enkelt.
O tror innehållet i filer där omgivningsvariablerna bytits ut blir tydligare:
Utan _DIR:
----------------------------------------
SHELLCHECK_ACT/data/dir/existing-file.txt
----------------------------------------
med _DIR:
----------------------------------------
SHELLCHECK_ACT_DIR/data/dir/existing-file.txt
----------------------------------------
Det blir helt enkelt tydligt att man pratar kataloger.

** TODO --rel-tmp : i assert-fasen ska det ange fil relativt tmp/
t ex
contents --rel-tmp transformed-stdout.txt --rel-home expected-contents.txt
* TODO Miljövariabler
** TODO Instruktioner: os.path.expandvars för att expandera miljövariabler
Finns även en
os.path.expanduser
för att expanera ~user.
** TODO Lägga till _DIR i slutet av katalog-variabler (ev skippa!!)
** DONE Ny miljövariabel: SHELLCHECK_RESULT_DIR
* TODO Kommandorads-program
** TODO Hjälpsystem via CLI
Förslag:
*** -h | --help : Elementär hjälp. Hjälp för hur använda kommandot "help"
*** Kommando "help" : om skrivs som första argument på CL
**** Enbart "help" : hjälp om hur använda "help"
**** help phase : Översikt över faserna
I vilken ordning de körs och deras inbördes roller.
**** help phase PHASE : Detaljerad info om fasen PHASE
**** help instruction : Översiktlig hjälp om instruktioner
**** help instruction INSTRUCTION : Detaljerad info om instr INSTRUCTION
** TODO Funktion för att köra assert/execute på given EDS
För felsökning av assert.
Tänkt användning:
1. Kör hela snurran (ev utom cleanup), och spara EDS.
   Troligtvis ger assert ett oväntat resultat som behöver felsökas.
2. Mixtra med innehållet i EDS.
3. Kör assert/execute på given EDS.
4. Upprepa 2-3 tills assert ger förväntat resultat.
5. Rätta till felet (i SUT, setup, act, el assert).
6. Radera EDS manuellt, eller kör shellcheck m växel som enbart kör cleanup,
   inklusive automatisk radering av EDS.  Kör denna mot angiven EDS.
** TODO Dok för enskild instr ska ges av funktion
Optimering: För att undvika att programmet alltid lägger tid på att ta fram
dokumentation.
Oftast kommer programmet att köras för att utföra ett testfall/svit, och
prioriteringen är att få det att gå hyfsat fort.
* TODO Formgivning av instruktionsuppsättning
** Anonyma fasen: Fixerad mängd instruktioner
Icke konfigurerbar pss som övriga faser, iom att denna fas har en speciell
uppgift att styra kommande faser.
** Instr har antingen arg enl argparse, eller skräddarsydd parsning
Skräddarsydd parsning funkar bäst för t ex instr i act-fasen som enbart är
källkod som ska kopieras till skriptet.
** Generella instr: Instr som kan köras i alla namngivna faser
Borde gå/finnas behov av att skriva generella instruktioner som kan köras i
vilken som helst av de namngivna faserna, eller kanske snarare, i vilken som
helst av faserna som har tillgång till EDS.
*** Ta fram SGD för dessa instruktioner (t ex EDS + HOME)
Ev är problemet här fasen "setup", vars "validate" inte har tillgång till EDS.
Kanske är det av den orsaken värt att skapa EDS innan setup/validate.
* TODO Göra det enkelt att utöka programmet m egen act-phase-setup
<2015-10-05 mån>
Osäker på hur användbart det är att ha olika act-phase-setup.  Men vore hur
som helst en "skyddande felxibilitet" om det vore enkelt (dvs på något sätt
förberett så att det inte krockar med något).
* TODO Test result
** TODO <2015-05-03 sön> Enhetstester för fast-steg-exekverare
Blir redundans om alla dess varianter ska testas via integrationstest.
Fallet som för tillfället orsakar problem är huruvida en fallerande
instruktion är den sista i raden eller ej.  (O borde kanske även testa då den
är den första ... dvs behöver UTFÖRLIGA tester av det här!)
** TODO <2015-05-03 sön> Använd mest informationsbärande status-koder internt
Fler fördelar:
 - möjliggör mest utförliga testerna
 - detfinns fler "externa" standarder: om har interna kan man översätta till
   godtycklig extern standard och kan på så vis integrera programmet i flera
   olika ramverk.
** TODO <2015-01-05 mån> Handle implementation errors
** TODO <2015-01-05 mån> Handle parse errors
** TODO <2015-01-05 mån> Handle errors correctly according to phase
* TODO Komplettera befintliga instruktioner
** TODO contents: env-var replacement
Notis i koden:
"TODO: Implement env-var replacement for arbitrary file."
* TODO Specifika instruktioner
** TODO Se över instruktionsnamn
Har nu valt att använda deklarativa namn.
Tex
 - workdir (ist f cd)
 - dir     (ist f mkdir)
 - file

Är detta bra?
Tycker det ökar läsbarheten.
Dock kan vara motiverat att använda inarbetade/standardiserade namn (som t ex
"cd" och "mkdir").
*** Olika konventioner för olika faser?
Ett alt är att använda olika konventioner för olika faser.  T ex skulle
setup-fasen kunna använda procedurella namn, medan assert-fasen använder
deklarativa.

Tanken har kommit efter att det känts att det kan vara konfunderande att i
setup-fasen ha instruktionen
----------
pwd my-dir
----------
eftersom den ser ut som ett test i assert-fasen: Assert att pwd = my-dir.

De faser som "utför" saker - setup o cleanup - skulle kunna ha procedurella
namn.
** TODO sök+ersätt
Är en vanlig informations-operation.  Är den vanlig i det här sammanhanget?
Vet inte.
Men innebär viss risk att inte ha den.

Vore bra att ha en sök+ersätt för reg-ex.
Vore bra om man kunde använda omgivningsvariablers värden i sök/ersätt
uttrycket.  Hur ska det göras?? Inte enkelt. Måste ha en syntax för att komma
åt dem. O den syntaxen får inte krocka med reg-exen.  Kanske enklast att (till
en början med, i varje fall) använda shell-syntax: ${ABC_abc_123}.
Om en annan syntax ska användas ska det vara en som krockar så lite som
möjligt med reg-ex syntax.
** TODO alla faser: Byta katalog till testrooten
Tycker för tillfället det är vettigast att varje fas inte inleds med att
automatiskt byta katalog till testroten.  Främsta anledningen är att
act-fasens byte av katalog måste betraktas som en sidoeffekt av programmet
som testsas och därmed som något man vill testa.

Även vettigt att setup-fasen kan skapa tmp-katalog och byta till den för att
köra act-fasen innifrån den (användbart t ex om act-fasen raderar aktuell
katalog).  Därmed är det vettigt att inte heller act-fasen inleds med att
automatiskt byta katalog.

Dock.  Vore bra om det enkelt gick att byta till testroten för att ha en fast
ugångspunkt för assert, cleanup, ...
Därför vore det bra med en instruktion som byter till denna katalog.

Problem ... hur ser man till att aktuell katalog bevaras från act-fasen om
den kör i en egen process??
** TODO Sätt systemets TMP-katalog till ${SHELLCHECK_TMP}
Används antingen i setup eller anonyma fasen.
** TODO Skapa temporär fil (filnamn tas fram automatiskt, läggs i SHELLCHECK_TMP)
** TODO file
*** TODO Använda syntax mer lik unix "test" och "find"?
Fördel iom att den är välkänd.
** TODO file/stdout/stderr --rel-cwd
*** TODO HARD_ERROR ifall jämförelsefilen inte finns?
Nu ges FAIL: felet betraktas som en form av olikhet.
*** TODO Bättre felmeddelande för stdout/stderr
Nu:
----------------------------------------
Line 68: `stdout    --rel-home output/absolute-file-paths-existing.txt'

Unexpected content in file: /tmp/shellcheck-290sqrhe/result/std/stdout
----------------------------------------
Det framgår inte tydligt att det handlar om stdout. Man får själv ana det,
genom att leta reda på "stdout".

Även när man använt --with-replaced-env-vars får man exakt samma meddelande.
Det framgår inte någonstans (förutom på källkodsraden) att det handlar om
varianten med variabler utbytta.
** TODO innehåll i fil (contents, stdout, stderr)
*** TODO Visa diff: undvika krash pga för stor fil
Tyvärr verkar diff-beräknaren inte vara lat: den vill ha in båda filerna i
minnet (i form av listor).
Ev behövs möjlighet att begränsa antal bytes som läses in i internminnet.
Möjlighet att sätta max gräns.
Ev även möjlighet att sätta övre gräns på antalet rader i diffen som visas.
Kanske räcker det med att hårdkoda ett max.
** TODO setup/install
*** DONE <2015-11-03 tis> Ska installera under Current Work Dir
Idag installeras hårdkodat under act-dir.
*** TODO <2015-11-03 tis> Hantering av multi-path-comp DESTINATION
Idag är beteendet för DESTINATION som innehåller flera path-komponenter
(t ex a/b/c) odefinierat.
*** TODO <2015-11-03 tis> Sök+ersätt i filer som installeras
Har ett testfall för filelist som gör just detta mha ex.
Ersättningsvärdet är absolut sökväg för testets rot (SHELLCHECK_ACT).
Antar att detta är relativt vanligt.  Därför borde shellcheck ha en sådan
funktion inbyggd.
** TODO mkdir
*** TODO Byt namn till "dir" el "directory"
Mer deklarativt.
*** TODO Lägg till till cleanup-fasen
*** TODO mkdir --rel-tmp DIRECTORY
Skapar katalog under tmp/user.
** TODO interpret/execute/source
Instruktion som kör/interpreterar kommando.
Kan göras via shell.  Men om det görs via skräddarsydd instruktion kan
programmet som ska köras reffas rel-home, och valideringssteget kan validera
att det reffade programmet verkligen existerar.
Namn?
 - run
 - exec (i Unix: denna byter ut aktuell process ... så inte helt rätt)
 - execute (rimmar bra med att det som körs måste vara exekverbart)
 - interpret (ev är detta en variant som tar interpreter som 1:a arg)
 - program
 - source
Finn något namn som andas deklarativt synsätt??
 - checker
 - assert
*** DONE För Unix: kör sh-kommandon (visat sig gå mha "shell")
T ex [ $(wc -l FILE) = 4 ]

Impl genom att ta raden (förutom instruktionen) o lägg i fil, o interpretera
den m sh/bash.
*** DONE Spara exitcode, stdout, stderr i filer
Kan skapa katalog som heter execute-line-LINENUM/{exitcode, stdout, stderr}
*** TODO Validering: att filen är exekverbar
Använd stat.S_IXUSR
Den kollar om filen är exekverbar för användaren.
Men ä osäker på om den enbart kollar om exekverings-flaggan är satt för
användaren.  Det räcker ju inte.  Ty den kan vara satt för gruppen, o aktuell
användare är medlem i gruppen som äger filen.
*** Syntax
Tre (1) olika instruktioner, eller (2) en enda m växlar???
Fördelar m separata instruktioner:
 - kan ge kortare syntax
Fördelar m en instruktion:
 - färre instruktioner att hålla reda på
 - skräpar ner namnrymnden mindre
Om man har enkel tillgång till makroprocessor så erbjuder
en-intruktions-alternativet fördelar i kombination med att det går att
"skriva" egna skräddarsydda "instruktioner" om man föredrar det.
Samt har sett att man kan ge skräddarsytt skal-program för shell/shell=True.
(dvs kan ange /bin/bash, t ex)
**** Varianter
***** Alla tar program/"interpretator" som arg
***** Kör: källkod
****** Källkod finns i fil
****** Källkod anges på som argument
***** Argument till körbart program: ja/nej
**** interpret INTERPRETER SOURCE-FILE ARGUMENTS
INTERPRETER är troligtvis ett globalt program.  Så utgångsvärde för
"relativitet" bör vara --global|--in-path|--system
(Om det inte är ett globalt program så borde man istället skrivit ett program
som kunnat exekveras med "execute".)

SOURCE-FILE är troligtvis något som skrivits just för testsvitens skull, så
där är --rel-home en lämpligt utgång.

ARGUMENTS är trol helt vanliga argument, dvs de shell-splittas.
**** execute   PROGRAM                 ARGUMENTS
PROGRAM kan både vara --rel-home och --system.  Svårt att välja utgång.

Dock, "shell" kan köra program som är i --system.  Med det i åtanke blir
--rel-home en naturligare utgång.

ARGUMENTS är trol helt vanliga argument, dvs de shell-splittas.
**** source    INTERPRETER             SOURCE
INTERPRETER är trol --in-system.  Om inte bör man skriva om det så att det
blir så - dvs att man skriver ett program som körs m "execute" och tar
ARGUMENTS istället för SOURCE som argument.  Sådana program är ju troligtvis
enklare att både skriva och läsa.
**** run: instruktion som hanterar alla fall
***** run PROGRAM ARGUMENTS
Exekverar: call([PROGRAM] ++ shell-split(ARGUMENTS))
Ex: run --rel-home my-property-checking-pgm PROPERTY-DEFINITION
***** run PROGRAM --interpret [--rel-X] FILE ARGUMENTS
Exekverar: call([PROGRAM,FILE] ++ shell-split(ARGUMENTS))
Här splittas ARGUMENT... enl shell-regler
***** run PROGRAM --source [SOURCE|<<EOF SOURCE EOF]
Exekverar: call([PROGRAM, SOURCE])
***** Former av PROGRAM
****** --rel-home|--rel-pwd|--rel-act|--rel-tmp PROGRAM
****** --system PROGRAM-IN-PATH
Bra för t ex "standardprogram" som awk, sed, där absolut sökväg kan variera
mellan OS.
*** Implementation
**** Växlar
***** För exekverbart program
   --system
   --rel-home
   --rel-pwd
   --rel-act
   --rel-tmp
***** För källkodsfil
   --rel-home
   --rel-pwd
   --rel-act
   --rel-tmp
**** Alla kommandon: 1:a arg är ett exekverbart program
Ev meningsfullt att införa koncept/klass ExecutableFile.
En skräddarsydd parser parsar en sådan.  Och den kan validera sig själv (för
"existens").

En sådan ExecutableFile är antingen en FileRef eller en system-global sak.  En
FileRef kan alltid resolvas till en abolut sökväg.

**** execute/interpret mkt lika varandra
Enda skillnaden är att interpret tar ett argument som förutsätts är en fil och
som därför ska valideras för "existens".
Själva exekveringen är annars identisk: EXECUTABLE ARGUMENT...
* TODO Faser
** TODO Byt namn "anonymous" -> "configuration"
** TODO Configuration
*** TODO <2015-09-26 lör> Builder för att modifiera conf + icke-builder
En builder som har en metod build() som ger ett immutabelt conf-objekt.
** TODO Setup
*** TODO <2015-09-26 lör> Builder för att modifiera conf + icke-builder
En builder som har en metod build() som ger ett immutabelt conf-objekt.

** TODO Act
*** TODO <2015-09-26 lör> Parser ska ha syntax för att inkl [abc]-rader i källkoden
Dessa rader är ju sektionsrubriker, och är därför omöjliga att inkludera i
källkod.  Parsern ska ha syntax som löser detta.
Förslag:
"[abc]"		: vanlig sektionsrubrik
"\[abc]"	: källkod: "[abc]"
"\\[abc]"	: källkod: "\[abc]"
"\\\[abc]"	: källkod: "\\[abc]"
Det är alltså enbart första o ev andra tecknet som hanteras speciellt.
Därefter är allt som vanligt.
* TODO Förbättringar
** TODO <2015-05-17 sön> Bevara glob tillstånd
Idag sparas omgivningsvariabler "runt" partiell exekvering.  Borde sparas runt
"full" exekvering, naturligtvis.
Vore bäst (känns nu) om hela exekveringen kunde ske i sub-process.
(se modul concurrent.futures)
** TODO <2015-05-18 mån> Ev skapa EDS senare
Enl diagram ska den skapas precis efter setup/validate.
Idag skapas den precis innan setup/validate.
Ingen stor grej, men kan ev ändras.
Alternativ ändrar man spec till att göra som idag.
** TODO <2015-05-22 fre> Konfbar gemensam miljö för alla instruktioner
Införa argument som ges till alla metoder i alla instruktioner.
Skulle erbjuda mölighet att skräddarsy den information som instruktionerna har
tillgång till.
* TODO Refaktoreringar
** TODO Göra sig av med fel-typen som är överflödig (fr UML, Failure?)
** TODO Argument till instruktionernas steg
Spikade först två generella miljöer: global miljö och fas-miljö.
Iom att den modellen inte längre används kan mer ändamålsenliga argument
användas.
*** TODO act/script-gen
Två argument:
1. Skriptbyggare
2. Inställningssättare (för t ex stdin).
** TODO Använda nya TestCaseSetup i äldre tester
Som du finns flera instruktions-klasser som enbart returnerar ett visst värde
eller kastar undantag.  Alla de fallen kan hanteras av nya TestCaseSetup.
* TODO Parsning av multi-rader
Har spånat (o experimenterat m två varianter)
** b-sne:
rad\
fortsätter\
mha b-sne

Har experimenterat m pythons shell-parsning.  (finns ev exempel nånstans).
Har kommit fram till att det går hyfsat att detektera b-sne på slutet av
raden - som inte ingår i quotade strängkonstanter.
** here-dokument
<<<EOF
Anger en sekvens av rader
på samma
sätt som HERE-dokument i shell.
EOF
** BNF
Tänker mig dok-syntax ("nivå 0") ung
rad ::= tom
      | kommentar
      | fasrubrik
      | instruktion
instruktion ::= enkel-radare
              | here-block
              | bne-separerade rader
* TODO Preprocessor
** TODO Inbyggd preprocessor
Vore bäst om programmet innehöll en egen preprocessor.
På så vis maximeras oberoende av yttre miljön.
Funktionallitet:
- filinklusion
- definitioner av konstanter
- definitioner av funktioner
Har tittat på:
*** PYM (mest lovande)
http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.400
Men hittar inte källkoden för den här.
*** Pythons inbyggda stängformattering (format())
file:///usr/share/doc/python3.4/html/library/string.html#string-formatting
Kanske är denna tillräckligt kraftfull för att fungera som preprocessor.
Dock förutom filinkludering, förutsätter jag.
** TODO Testa ange preprocessor för TF via kommandoraden
* TODO Härleda interpretator
bash, sh, csh ...???
Går det att ta reda på ett utgångsvärde för interpretator för varje plattform
(dvs via python)?  El måste den anges explicit?
* TODO Testa på andra plattformar (Windows, Mac)
Ev måste hanteringen av ny-rader justeras.
python har ju något som heter "universal newlines".  Ev ska det användas (om
det inte redan används idag!)
* TODO Svit
** TODO Hjälp-funktionallitet för svit-kommandot
** TODO Svit: Reffa flera fall-filer mha jokertecken
Typ:
[cases]
sub-dir/*.case

** TODO Gruppering av testfall
Ev ange i varje enskilt testfall:
groups database groupX groupY

Ev ange i svit-filerna.  På sätt o vis är det ju enbart i svit-filerna grupper
är relevanta iom att det enbart där är meningsfullt att arbeta med grupper av
fall.
Skulle kunna ha instruktion "@groups" i svit-filer (mycket liknande hur
filelist använder @tags).
** TODO Köra enskilda testfall i sub-process
** TODO <2015-07-14 tis> Rapportering: Borde inte rappoteringen vara rekursiv?
Nu (djupet-först):
----------------------------------------
sub-suite: BEGIN
sub-case: PASS
sub-suite: END

main-suite: BEGIN
main-case: PASS
main-suite: END
----------------------------------------
Borde det inte vara:
----------------------------------------
main-suite: BEGIN

sub-suite: BEGIN
sub-case: PASS
sub-suite: END

main-case: PASS
main-suite: END
----------------------------------------

Dagens impl har fördelningen att en svits BEGIN o END inkapslar "direkt"
svitens egna testfall.
Nackdelen är att det inte går att spåra inklusions-hierarkin.
Frågan är vad som är vettigast.  Borde kolla på hur andra gör o följa det
vanliga sättet.
(Makefiler kör enl icke-nuvarande.  Å andra sidan har man inget val där, iom
att det handlar om att "överliggande" moduler är beroende av "underliggande".
El, jo, i rapporteringen har man naturligtvis ett val!  Dock inte i själva
beräkningsordningen.)
** TODO <2015-09-26 lör> Miljövariabler - köra varje tc i separat process
Miljövariabler medför problem för test-sviter, iom att de är globala, o därmed
ändrar förutsättningarna för efterföljande test.
Egentligen är det enda vettiga att köra varje test i en separat process.
Då kan instruktioner i [setup] sätta miljövariabler.
Det finns en fuktion os.fork, men denna är enbart tillgänglig i Unix.
Ev behöver det införas ett nytt koncept: SubProcessTestCaseExecutor, som
exekverar ett testfall i en sub-process.  Denna kan behöva implementeras olika
för unix/övrigt.

Har för mig att i dagsläget så sparar+återställer full_execution alla
miljövariabler.  Det ska den inte behöva göra.  Speciellt när ett enda
test-fall körs är det helt onödigt eftersom shellcheck kör i en separat
process, vars sidoeffekter i form av miljövariabler försvinner när det
avslutas.

Ett alternativ är att låta det exekverbara programmet sätta dem.  Men då
förändrar man SUT, vilket inte alls är bra.

Ytterligare ett alternativ är att
 1. Låta instruktioner förändra miljövariabler indirekt genom att lägga
    ändringarna i en lista.
 2. Låta ett program som kör precis innan SUT, ändra de faktiska variablerna i
    enlighet med denna lista och sedan köra SUT som en sub-process.

Detta är dock krångligt!!

* TODO Loggning
* TODO Preprocessning
* TODO Faser och steg
** TODO Nytt steg cleanup/validate
T ex för att göra möjligt för en instruktion "interpret PROGRAM" att validera
att en reffade programfil existerar --rel-home.
** TODO Instr i alla faser borde ha validering pre-EDS
Eftersom en instruktion i varje fall (ev utom config) kan referera filer i
home.  O fel där kan upptäckas innan man skapar EDS.
----------------------------------------
Typ: validate_pre_eds(eds: ExecutionDirectoryStructure)
----------------------------------------
* TODO Blandat
** TODO <2015-09-26 lör> Funktioner för att läsa act-resultat
Ska finnas hjälpfunktioner i "biblioteket" för att läsa t ex statuskod på
korrekt sätt - dvs kasta rätt undantag om något går snett.
Idag läser t ex instruktionen "exitcode" själv exitkoden. Det ska den inte
behöva göra.
** TODO Instr-namn-parser: "_" ska kunna ingå i instruktionsnamn
* TODO Prestanda
** TODO All dokumentation ska skapas vid behov
Dvs ska inte finnas konstater på global nivå.
Ska istället finnas funktioner på global nivå:
def get_document() -> Description:
  return Description(...)

* Vidareutveckling
** TODO <2015-11-04 ons> Ange filstruktur i textformat att installera
På liknande sätt som jag gör i Python:
DirContents([File('f','contents'], Dir('d', [...]))

Vore ju bekvämt om det fanns en liknande notation för filer att installera.
Då skulle man slippa ha dem i filsystemet, i de fall det inte är nödvändigt av
andra orsaker.

Kruxet är bra syntax.
Alternativ:
 - egendefinierad
 - JSON
 - XML

T ex
----------------------------------------
[setup]
file-structure --xml <<EOF
<contents>
  <file name="empty-file"/>
  <file name="g" timestamp="2015-11-03 10:20:30"/>
  <file name="non-empty">contents of file</file>
  <dir name="empty-dir"/>
  <dir name="non-empty-dir">
    <file name="f"/>
  </dir>
<contents>
EOF
----------------------------------------

Ev kunde ett antal xml entities sättas så att de fanns att tillgå, på ung
samma sätt som med omgivningsvariabler.


assert/JÄMFÖRELSE
Vore naturligtvis även användbart att kunna asserta att innehållet i en
katalog är identiskt (el innehåller som minst) en sådan hårdkodad filstruktur.
