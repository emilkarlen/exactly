-*- org -*-

Store output from programs in files

<2017-12-05 tis>

Exactly uses Files as a substitute for variables.
This means that it should/must be possible to store a lot of things in a file:
 - nothing (an empty file)
 - hard coded contents
 - copy of existing file (perhaps transformed)
 - output from program

file PATH

file PATH = CONTENTS

CONTENTS ::= HERE-DOCUMENT
         ::| STRING
         ::| [TRANSFORMATION] --file PATH-OF-EXISTING-FILE
         ::| [TRANSFORMATION] [--stdout|--stderr] SHELL-COMMAND-OR-PROGRAM

SHELL-COMMAND-OR-PROGRAM ::= PROGRAM [ARGUMENT]...
                         ::| $ SHELL-COMMAND


TRANSFORMATION ::= --transformed LINES-TRANSFORMER

* Changes of current setup

The "transform" instruction can be replaced with

file PATH = [TRANSFORMATION] --file EXISTING-FILE

* Examples

The "git-hook" example

Current:
----------------------------------------
[before-assert]


$ git log > log.txt

transform log.txt actual-commit-msg.txt GET_FIRST_LOG_MESSAGE


[assert]


exitcode = 0

contents actual-commit-msg.txt equals <<EOF
AB-123 : commit message without issue number
EOF
----------------------------------------

Using new "file":

----------------------------------------
file log.txt = --stdout $ git log

transform log.txt actual-commit-msg.txt GET_FIRST_LOG_MESSAGE

...
----------------------------------------

or

----------------------------------------
file log.txt = --stdout $ git log

file actual-commit-msg.txt = --transformed GET_FIRST_LOG_MESSAGE
                             --file log.txt 

...
----------------------------------------

or

----------------------------------------
file commit-msg.txt = --transformed GET_FIRST_LOG_MESSAGE
                      $ git log

...
----------------------------------------

alt

----------------------------------------
file commit-msg.txt = --transformed GET_FIRST_LOG_MESSAGE
                      --stdout $ git log

...
----------------------------------------

----------------------------------------
file commit-msg.txt = --transformed GET_FIRST_LOG_MESSAGE
                      --stdout
                      $ git log

----------------------------------------

----------------------------------------
file commit-msg.txt = --transformed GET_FIRST_LOG_MESSAGE
                      --stdout
                      my-helper-prog-in-case-home "with" "arguments"

----------------------------------------

----------------------------------------
file commit-msg.txt = --transformed GET_FIRST_LOG_MESSAGE
                      --stdout
                      @[MY_HELPER_PROGRAM]@ "with" "arguments"

----------------------------------------

----------------------------------------
file commit-msg.txt = $ git log
                      --transformed GET_FIRST_LOG_MESSAGE
                      

...
----------------------------------------



----------------------------------------

file f = other-file.txt --transformed GET_FIRST_LOG_MESSAGE

file f = other.txt | GET_FIRST_LOG_MESSAGE

file f = $ git log | GET_FIRST_LOG_MESSAGE

file f = $ git log | head | GET_FIRST_LOG_MESSAGE

file f < git log

file f = run my-program

file f = $( git log )

** Parentheses around program

file f = ( $ git log )

file f = ( run my-prog "arg" ) --transformd GET_FIRST_LOG_MESSAGE

file f = ( my-prog "arg" )     --transformd GET_FIRST_LOG_MESSAGE

file f = ( my-prog "arg" ) | GET_FIRST_LOG_MESSAGE

file f = ( $ git log | sed ) | GET_FIRST_LOG_MESSAGE

file f = a-string

file f = --file --transformed GET_FIRST_LOG_MESSAGE other.txt

file f = --transformed GET_FIRST_LOG_MESSAGE --file other.txt

file f = my-file.txt --transformed GET_FIRST_LOG_MESSAGE


